# Домашнее задание к занятию "3.2. Работа в терминале, лекция 2"
1. Команда cd является внутренней командой shell. Предполагаю что она такого типа в связи с тем что её задача менять свойство "текущий рабочий каталог" запущенного процесса shell. Предполагаю, что т.к. свойство "текущий рабочий каталог" есть у всех запущенных процессов, то если бы CD была программой, она просто меняла бы рабочий каталог своего процесса и завершалась бы, при этом в shell, из которого она была запущена, рабочий каталог оставался бы неизменным.
2. Команду ```grep <some_string> <some_file> | wc -l``` можно заменить командой ```grep <some_string> <some_file> -с``` она также выдаст количество найденных строк.
3. На моей виртуальной машине процесс с PID 1 - это systemd
4. Перенаправить вывод stderr команды ls на другую сессию терминала можно командой ```ls 2> /dev/pts/1```
5. Получится. Пример: ```cat < 1.txt > 2.txt```
6. Работает в обе стороны ```ls > /dev/tty3``` из терминала в графической сессии в сессию без графики и ```ls > /dev/pts/0``` из терминала без графики в терминал графической сессии.
7. Команда ```bash 5>&1``` создаёт новый поток данных по аналогии с stdin, stdout и stderr и перенаправляет его вывод в stdout. Команда ```echo netology > /proc/$$/fd/5``` перенаправляет вывод сообщения "netology" в созданный нами ранее поток данных, который в свою очередь перенаправляется на stdout.
8. Это возможно, для этого сначала необходимо выполнить команду ```bash 5>&1``` для создания нового потока данных, поменять все потоки местами так чтобы получать на вывод stdout, а stderr перенаправлять через ```|```.  
Пример команды: ```ls / /123 5>&2 2>&1 1>&5 | tee 1.txt```. В качестве вывода в терминал мы получим список файлов из корневой директории, а в файл 1.txt уйдёт ошибка о том что директории /123 не существует.
9. Команда ```cat /proc/$$/environ``` выводит список переменных окружения. Вывода того же списка в более читаемом виде можно добиться командами ```env``` или ```printenv```.
10. * По адресу ```/proc/<PID>/cmdline``` находится файл содержащий командную строку запуска исполяемого процесса.
    * По адресу ```//proc/<PID>/exe``` находится файл содержащий символьную ссылку на путь исполняемой команды.
11. Судя по выводку команды ```cat /proc/cpuinfo | grep sse``` мой процессор поддерживает набор инструкций SSE версии 4
12. Если в ssh определена команда, то она просто запускается на удалённом хосте без входа в shell, в связи с этим и получаем вывод ```not a tty```. Для решения этой проблемы можно использовать опцию -t для принудительного запуска команды в псевдо-терминале.  
Например: Команда ```ssh -t localhost 'tty'``` вернет нам ```/dev/pts/1```
13. Перечень действий для переноса запущенного процесса в другую сессию:  
    1. Запускаем ```top``` в ssh сессии.
    2. Уводим процесс в фон нажатием сочетания клавиш ```Ctrl+Z```
    3. Узнаем ID процесса в выводе команды ```jobs -l```
    4. Отсоединяем процесс от текущего родителя командой ```disown top```
    5. Выполняем команду ```screen```
    6. Выполняем команду ```reptyr 1277```
    7. После этого можно отключаться от screen при помощи нажатия сочетания клавиш ```Ctrl+A``` и последующего нажатия клавиши D.
    8. Теперь запущенный изначально в ssh сесси top работает в терминале созданном при помощи screen
14. Команда tee читает stdin и пишет полученные данные в stdout и указанный файл. В отличии от перенаправлений потоков, которые выполняются от лица текущего пользователя shell команду tee можно запустить при помощи sudo что позволит ей записывать информацию в файл доступ к которому имеет только root.